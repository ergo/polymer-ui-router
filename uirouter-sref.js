/**
`uirouter-sref`
Element that generates `<a>` tag with contents.

For links with custom attributes for state params you should be using `property-foo$=[[value]]` notation.

@demo demo/demo-sref.html uirouter-sref element demo
*/

import { PolymerElement } from '@polymer/polymer/polymer-element.js';

import UiRouterMixin from './uirouter-mixin.js';

class UiRouterSref extends UiRouterMixin(PolymerElement) {
    static get is() {
        return "uirouter-sref";
    }

    static get properties() {
        return {
            /** The name of the state to link to */
            state: {
                type: String,
                observer: '_updateState'
            },
            /** Sets whether or not the transition's parameter values should be inherited from the current parameter values. */
            inherit: {
                type: Boolean,
                value: false
            },
            /** your own Transition Options inside this property and use them, e.g., from a Transition Hook  */
            custom: {
                type: Object,
                value: null
            },
            /** Changes how the Transition interacts with the browser's location bar */
            noLocation: {
                type: Boolean,
                value: false
            },
            /** force states which are currently active to reload */
            reload: {
                type: Boolean,
                value: false
            },
            /** When transitioning to relative path (e.g '^'),
             * this option defines which state to be relative from.  */
            relative: {
                type: String,
                value: '$state.current'
            },
            linkRel: String,
            linkTarget: String,
            /** The parameter values to use (as key/values) */
            params: {
                type: Object,
                value: null,
                observer: '_updateParams'
            },
            /** compiled params */
            _params: {
                type: Object,
                value: null
            },
            /**
             * Link url generated by this element (legacy)
             */
            generatedURL: {
                type: String,
                notify: true
            },
            /**
             * Link url generated by this element
             */
            generatedUrl: {
                type: String,
                notify: true
            },
            /**
             * Time that (in ms) url generator should debounce before generating url
             */
            debounceTime: {
                type: Number,
                value: 0
            }
        }
    }

    _toCamelCase(input) {
        let output = input[0].toUpperCase() + input.slice(1);
        return output;
    }

    getParams() {
        let params = this.params || {};
        // handle attributes
        for (let x = 0; x < this.attributes.length; x++) {
            let item = this.attributes[x];
            if (item.name.indexOf('param-') === 0) {
                let name = item.name.slice(6);
                let segments = name.split('-');
                name = segments[0] + segments.slice(1).map(this._toCamelCase).join('');
                params[name] = item.value;
            }
        }
        // handle props
        let props = Object.getOwnPropertyNames(this).filter(function (p) {
            return p.indexOf('param') == 0
        });
        props.forEach((k, i) => {
            params[k[5].toLocaleLowerCase() + k.slice(6)] = this[k];
        });
        this._params = params;
        return params;
    }

    // notify sref-active elements that their children properties have changed
    _updateParams(newValue, oldValue) {
        if (!this.state || typeof newValue === 'undefined' || typeof oldValue === 'undefined') {
            return
        }
        this.dispatchEvent(
            new CustomEvent('uirouter-sref-detached',
                {detail: {state: this.state, params: oldValue}, bubbles: true, composed: true}));
        this.dispatchEvent(
            new CustomEvent('uirouter-sref-attached',
                {detail: {state: this.state, params: newValue}, bubbles: true, composed: true}));
        this.computeLink();
    }

    _updateState(newValue, oldValue) {
        if (!this.state || typeof newValue === 'undefined' || typeof oldValue === 'undefined') {
            return
        }
        this.dispatchEvent(
            new CustomEvent('uirouter-sref-detached',
                {detail: {state: oldValue, params: this._params}, bubbles: true, composed: true}));
        this.dispatchEvent(
            new CustomEvent('uirouter-sref-attached',
                {detail: {state: this.state, params: this._params}, bubbles: true, composed: true}));
        this.computeLink();
    }

    connectedCallback() {
        super.connectedCallback();
        this.computeLink();
        this.dispatchEvent(
            new CustomEvent('uirouter-sref-attached',
                {detail: {state: this.state, params: this._params}, bubbles: true, composed: true}));
        this.addEventListener('click', this.handleClick.bind(this));
        this._observer = new MutationObserver(mutations => {
            this._computeLink();
        });
        this._observer.observe(this, {attributes: true});
    }

    disconnectedCallback() {
        super.disconnectedCallback();
        this.dispatchEvent(
            new CustomEvent('uirouter-sref-detached',
                {detail: {state: this.state, params: this._params}, bubbles: true, composed: true}));
        this.removeEventListener('click', this.handleClick.bind(this));
        this._observer.disconnect();
    }

    computeLink() {
        if (this.debounceTime > 0) {
            this.debounce('computeLink', this._computeLink, this.debounceTime);
        }
        else {
            this._computeLink();
        }
    }

    _assembleOptions() {
        return {
            inherit: this.inherit,
            custom: this.custom,
            location: !this.noLocation,
            relative: this.relative,
            reload: this.reload
        };
    }

    _computeLink() {
        let params = this.getParams();
        this.generatedUrl = this.uiRouter.stateService.href(this.state, params, this._assembleOptions());
        // bwcompat
        this.generatedURL = this.generatedUrl;
        this._updateMarkup();
    }

    _updateMarkup() {
        let slottedNodes = [];
        for (let i = 0; i < this.childNodes.length; i++) {
            // when updating the element the node might already wrap with A tag, so get the children
            if (this.childNodes[i].nodeType === Node.ELEMENT_NODE && this.childNodes[i].classList.contains("uirouter-link")) {
                slottedNodes = [];
                for (var j = 0; j < this.childNodes[i].childNodes.length; j++) {
                    slottedNodes.push(this.childNodes[i].childNodes[j]);
                }
                break
            }
            slottedNodes.push(this.childNodes[i]);
        }

        while (this.hasChildNodes()) {
            this.removeChild(this.lastChild);
        }
        let link = document.createElement('a');
        link.className = 'uirouter-link';
        link.href = this.generatedUrl;
        if (this.linkTarget) {
            link.target = this.linkTarget;
        }
        if (this.linkRel) {
            link.rel = this.linkRel;
        }
        slottedNodes.forEach(n => link.appendChild(n));
        this.appendChild(link);
    }

    handleClick(event) {
        if (!event.defaultPrevented && !(event.shiftKey || event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            this._computeLink();
            this.uiRouter.stateService.go(this.state, this._params, this._assembleOptions());
        }
    }
}

// Register the new element with the browser
customElements.define(UiRouterSref.is, UiRouterSref);
