<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="uirouter-mixin.html">

<!--
`uirouter-sref`
Element that generates `<a>` tag with contents.

For links with custom attributes for state params you should be using `property-foo$=[[value]]` notation.

@demo demo/demo-sref.html uirouter-sref element demo
-->

<script>
    (function () {

        class UiRouterSref extends UiRouterMixin(Polymer.Element) {
            static get is() {
                return "uirouter-sref";
            }

            static get properties() {
                return {
                    /** The name of the state to link to */
                    state: {
                        type: String,
                        observer: '_updateState'
                    },
                    /** Sets whether or not the transition's parameter values should be inherited from the current parameter values. */
                    inherit: {
                        type: Boolean,
                        value: false
                    },
                    /** your own Transition Options inside this property and use them, e.g., from a Transition Hook  */
                    custom: {
                        type: Object,
                        value: null
                    },
                    /** Changes how the Transition interacts with the browser's location bar */
                    noLocation: {
                        type: Boolean,
                        value: false
                    },
                    /** force states which are currently active to reload */
                    reload: {
                        type: Boolean,
                        value: false
                    },
                    /** When transitioning to relative path (e.g '^'),
                     * this option defines which state to be relative from.  */
                    relative: {
                        type: String,
                        value: '$state.current'
                    },
                    linkRel: String,
                    linkTarget: String,
                    /** The parameter values to use (as key/values) */
                    params: {
                        type: Object,
                        value: null,
                        observer: '_updateParams'
                    },
                    /** compiled params */
                    _params: {
                        type: Object,
                        value: null
                    },
                    /**
                     * Link url generated by this element (legacy)
                     */
                    generatedURL: {
                        type: String,
                        notify: true
                    },
                    /**
                     * Link url generated by this element
                     */
                    generatedUrl: {
                        type: String,
                        notify: true
                    },
                    /**
                     * Time that (in ms) url generator should debounce before generating url
                     */
                    debounceTime: {
                        type: Number,
                        value: 0
                    }
                }
            }

            _toCamelCase(input) {
                let output = input[0].toUpperCase() + input.slice(1);
                return output;
            }

            getParams() {
                let params = this.params || {};
                // handle attributes
                for (let x = 0; x < this.attributes.length; x++) {
                    let item = this.attributes[x];
                    if (item.name.indexOf('param-') === 0) {
                        let name = item.name.slice(6);
                        let segments = name.split('-');
                        name = segments[0] + segments.slice(1).map(this._toCamelCase).join('');
                        params[name] = item.value;
                    }
                }
                // handle props
                let props = Object.getOwnPropertyNames(this).filter(function (p) {
                    return p.indexOf('param') == 0
                });
                props.forEach((k, i) => {
                    params[k[5].toLocaleLowerCase() + k.slice(6)] = this[k];
                });
                this._params = params;
                return params;
            }

            // notify sref-active elements that their children properties have changed
            _updateParams(newValue, oldValue) {
                if (!this.state || typeof newValue === 'undefined' || typeof oldValue === 'undefined') {
                    return
                }
                this.dispatchEvent(
                    new CustomEvent('uirouter-sref-detached',
                        {detail: {state: this.state, params: oldValue}, bubbles: true, composed: true}));
                this.dispatchEvent(
                    new CustomEvent('uirouter-sref-attached',
                        {detail: {state: this.state, params: newValue}, bubbles: true, composed: true}));
                this.computeLink();
            }

            _updateState(newValue, oldValue) {
                if (!this.state || typeof newValue === 'undefined' || typeof oldValue === 'undefined') {
                    return
                }
                this.dispatchEvent(
                    new CustomEvent('uirouter-sref-detached',
                        {detail: {state: oldValue, params: this._params}, bubbles: true, composed: true}));
                this.dispatchEvent(
                    new CustomEvent('uirouter-sref-attached',
                        {detail: {state: this.state, params: this._params}, bubbles: true, composed: true}));
                this.computeLink();
            }

            connectedCallback() {
                super.connectedCallback();
                this.computeLink();
                this.dispatchEvent(
                    new CustomEvent('uirouter-sref-attached',
                        {detail: {state: this.state, params: this._params}, bubbles: true, composed: true}));
                this.addEventListener('click', this.handleClick.bind(this));
                this._observer = new MutationObserver(mutations => {
                    this._computeLink();
                });
                this._observer.observe(this, {attributes: true});
            }

            disconnectedCallback() {
                super.disconnectedCallback();
                this.dispatchEvent(
                    new CustomEvent('uirouter-sref-detached',
                        {detail: {state: this.state, params: this._params}, bubbles: true, composed: true}));
                this.removeEventListener('click', this.handleClick.bind(this));
                this._observer.disconnect();
            }

            computeLink() {
                if (this.debounceTime > 0) {
                    this.debounce('computeLink', this._computeLink, this.debounceTime);
                }
                else {
                    this._computeLink();
                }
            }

            _assembleOptions() {
                return {
                    inherit: this.inherit,
                    custom: this.custom,
                    location: !this.noLocation,
                    relative: this.relative,
                    reload: this.reload
                };
            }

            _computeLink() {
                let params = this.getParams();
                this.generatedUrl = this.uiRouter.stateService.href(this.state, params, this._assembleOptions());
                // bwcompat
                this.generatedURL = this.generatedUrl;
                this._updateMarkup();
            }

            _updateMarkup() {
                let slottedNodes = [];
                for (let i = 0; i < this.childNodes.length; i++) {
                    // when updating the element the node might already wrap with A tag, so get the children
                    if (this.childNodes[i] === Node.ELEMENT_NODE && slottedNodes[i].classList.contains("uirouter-link")) {
                        slottedNodes = slottedNodes[i].childNodes;
                        break
                    }
                    slottedNodes.push(this.childNodes[i]);
                }

                while (this.hasChildNodes()) {
                    this.removeChild(this.lastChild);
                }
                let link = document.createElement('a');
                link.className = 'uirouter-link';
                link.href = this.generatedUrl;
                if (this.linkTarget) {
                    link.target = this.linkTarget;
                }
                if (this.linkRel) {
                    link.rel = this.linkRel;
                }
                slottedNodes.forEach(n => link.appendChild(n));
                this.appendChild(link);
            }

            handleClick(event) {
                if (!event.defaultPrevented && !(event.shiftKey || event.metaKey || event.ctrlKey)) {
                    event.preventDefault();
                    this._computeLink();
                    this.uiRouter.stateService.go(this.state, this._params, this._assembleOptions());
                }
            }
        }

        // Register the new element with the browser
        customElements.define(UiRouterSref.is, UiRouterSref);

    })()


</script>
